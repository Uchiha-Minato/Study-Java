# JVM内存结构

    1.PC Register 程序计数器
    2.JVM Stacks 虚拟机栈
    3.Native Method Stack 本地方法栈
    4.Heap 堆
    5.Method Area 方法区

## 1.程序计数器 - Program Counter Register(寄存器)

**作用：记住下一条JVM指令的执行地址**

    PC是Java对物理硬件的屏蔽和抽象 
    PC在物理上通过寄存器实现

特点： 
    
    1.线程私有 - 一个PC属于一个线程
    2.不存在内存溢出（Java中唯一）

## 2.虚拟机栈 - JVM Stacks

    栈 - 后进先出 线性结构
    **虚拟机栈 - 每个线程运行需要的内存空间**
    栈帧 - 栈内元素
    虚拟机栈栈帧 - 每个方法调用时需要的内存

**每个线程只能有一个活动帧栈**，对应着当前正在执行的方法，**在本线程JVM栈栈顶**

### 问题分析

    Q1.垃圾回收是否涉及栈内存
    A1:不涉及。JVM GC机制只回收堆内存中不再被引用的对象，而栈内存中是一次次方法调用所产生的内存，其随着方法结束调用而自动释放。

    Q2.栈内存分配越大越好吗
    A2.不是。栈内存（线程运行时需要的内存）分配越大线程数量越少（物理内存大小一定）。

    Q3.方法内局部变量是否线程安全
    A3.安全。因为局部变量线程私有。若是类似static共享变量 则需要考虑线程安全。
    若是变量引用了对象并逃离了方法的作用范围（作为参数传入或是作为返回值返回）就不再线程安全。

![threadOwn](./Pictures/局部变量线程私有.png)

### 栈内存溢出

有几种情况

    1.栈帧过多导致栈内存溢出（典型为递归调用）
    2.栈帧过大导致栈内存溢出（不容易出现）

**抛出异常 - java.lang.StackOverflowError**

### 线程诊断

案例1：cpu占用过多

    Linux下
    1.先用top定位哪个进程对cpu占用高
    2.ps H -eo [pid,tid,%cpu] | grep [pid]
    3.jstack 进程id（JVM的工具）返回线程的HEX编号，进一步定位到问题代码的源码行数

案例2：程序运行很长时间没有结果（线程死锁）


## 3.本地方法栈 - Native Method Stacks

**JVM在调用本地方法时 给这些方法提供的内存空间**

    本地方法 - 不是由Java代码编写的方法
    如使用C/C++编写的访问操作系统的方法
    java.lang.Object中的
    public native int hashCode()方法

## 4.堆 - Heap

**通过new创建的对象都会使用堆内存**

特点

    1.线程共享，需要考虑线程安全
    2.有GC（垃圾回收）机制

### 堆内存溢出

**抛出错误 - java.lang.OutOfMemoryError: Java heap space**

### 堆内存诊断

    1.jps工具 - 查看当前系统中有哪些Java进程
        jps返回进程pid和进程名
    2.jmap工具 - 查看堆内存占用情况
        jmap -heap [pid]
    3.jconsole工具 - 图形界面多功能监测工具

 
