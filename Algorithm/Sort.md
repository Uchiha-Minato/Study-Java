# 八大排序算法

    直接选择排序
    堆排序
    直接插入排序
    希尔排序
    冒泡排序
    快速排序
    归并排序
    基数排序

*稳定性及复杂度：*

![](https://img-blog.csdnimg.cn/20210327002454253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjE1NTc3,size_16,color_FFFFFF,t_70)

    插帽龟 它很稳
    插帽龟喜欢选帽插 插完就慌(方)了
    快归堆 n老

*插入 冒泡 归并 - 稳定的排序算法* <br>
*选择 冒泡 插入 - 平均时间复杂度为O(n^2)* <br>
*快排 归并 堆排序 - 平均时间复杂度O(nlogn)*

## 1.直接插入排序 - 和前面的比，找到对应位置插入

算法思想：

插入第i(i>=1)个元素时，前面的array[0],array[1],…,array[i-1]已经排好序

此时用array[i]的排序码与 array[i-1],array[i-2],…的排序码顺序进行比较，找到插入位置即将array[i]插入，原来位置上的元素顺序后移

性能特点：

    平均O(n^2) 稳定 元素集合越接近有序，效率越高

## 2.希尔排序 - 对每一个子表进行直接插入排序

又称缩小增量法，是对直接插入的改进。算法思想：

先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序 - gap步长

然后依次缩减增量(如gap = gap/2)再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序(gap = 1)。

当gap > 1时都是预排序，目的是让数组更接近有序，能大幅提升最后直接插入排序的效率

![](https://pic1.zhimg.com/v2-7ef755d2b04f11cb013acb47f10928cc_r.jpg)

性能特点：

    平均O(n^1.3) 不稳定 适合小数组小数据

## 3.冒泡排序 - 两两对比，交换位置即可

    public static void bubbleSort(int[] arr) {
        for(int i = 0; i < arr.length; i++) {
            for(int j = 0; j < arr.length - i; j++) {
                if(arr[j] > arr[j+1]) {
                    int tmp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = tmp;
                }
                System.out.println("第"+ i +"趟冒泡:");
                for(int k : arr) {
                    System.out.println(k + " ");
                }
            }
        }
    }

## 4.快速排序 - 分治算法典型应用之一

算法思想：

取待排序数组的第一个数作为基准值，按照该数将待排序集合分割成两子序列，左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止。

![quicksort](/Pictures/quicksort.jpg)

性能特点：

    平均O(nlogn) 不稳定 适合又大又乱的数据集合

## 5.直接选择排序 - 先扫，再找，放入最前

算法思想：

每一次从待排序的数据元素中选出最小（或最大）的一个元素，放在序列开头位置。

例如，序列前i个元素已经有序，从第i+1到第n个元素中选择关键字最小的元素，假设第j个元素为最小元素，则交换第j个元素与第i+1个元素的位置。依次执行此操作，直到第n-1个元素也被确定。

![selectionsort](https://img-blog.csdnimg.cn/20210327011441920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjE1NTc3,size_16,color_FFFFFF,t_70)

性能特点：

    平均O(n^2) 不稳定 实际很少使用

## 6.堆排序 - 堆：完全二叉树，逻辑结构 实际上是线性表

    先建堆，再找数 （通常情况下是大根堆）
    找一次，建一次
    找到数，就输出
    输出完，排序完

大根堆：根 > 左右孩子，递归满足

算法步骤：

    a.建立大根堆：
    按照层序遍历的顺序把数组中的元素做成完全二叉树
    然后检查所有的非叶子结点，看是否满足 根 > 左右孩子，若不满足，则交换位置。

    交换位置时，从最后一个非叶子结点开始查看。

    b.找数：找最大的（即根节点）
    c.输出：和层序遍历最后的叶子结点换位置 然后输出

    这里输出的元素即为当前大根堆中最大的元素。

换完位置并输出之后，重复a.b.c的步骤，直到全部元素输出完毕。

性能特点：

    平均O(nlogn) 不稳定 
    一般用于寻找M个数中的前K个最小的数并保持有序

## 7.归并排序 - 分治算法的又一个典型应用

先使每一个子序列有序，再使子序列段间有序。

合并时另外建表，分别从序列两头依次对比。

归并排序是用分治思想，分治模式在每一层递归上有三个步骤：

    分解（Divide）：将n个元素分成个含n/2个元素的子序列。
    解决（Conquer）：用合并排序法对两个子序列递归的排序。
    合并（Combine）：合并两个已排序的子序列已得到排序结果。

![mergesort](https://pic4.zhimg.com/v2-2958d4f3d9dd9156f1b5dca6788fe8a7_r.jpg)

性能特点：

    平均O(nlogn) 稳定 速度仅次于快排
    一般用于总体无序，部分有序的集合

## 8.基数排序 - 基你太稳

存储结构：链式存储结构 + 队列

先排个位，再排十位，百位...

按照那位数的数值加入队列，如

    排个位时，47 和 27排在一起
    排十位时，59 和 51排在一起

![](/Pictures/基数排序.png)