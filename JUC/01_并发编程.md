# JUC并发编程

## 1. 进程与线程

### 1.1 进程 Progress

**进程是操作系统中资源分配的基本单位，可以看成是线程的容器。**

- *主要作用：加载指令，管理内存，管理IO*

- 当一个程序被运行，从磁盘加载这个程序的代码到内存，这时就开启了一个进程。

- 进程可以视为程序的一个实例。**大部分程序可以同时运行多个实例。**

### 1.2 线程 Thread

**线程是操作系统中最小的调度单位。一个进程由多个线程组成。**

### 1.3 进程与线程对比

- 进程基本上相互独立，而线程是进程的一个子集。

- 进程拥有共享的资源（如内存空间），供其内部的线程共享。

- 进程之间的通信较为复杂

    同一台计算机的进程通信称为IPC（Inter-process communication）
    不同计算机之间的进程通信，需要通过网络，共同遵守相同的协议。（HTTP）

- 线程通信相对简单，因为它们共享进程内的内存。

- 线程更轻量级，线程之间切换（上下文切换）成本一般比进程间切换低。

## 2. 并行和并发

### 2.1 并行 Parallel - 同一时间动手做多件事的能力

*硬性条件：多核心CPU才能并行*

**多个线程同时运行。**

### 2.2 并发 Concurrent - 同一时间应对多件事情的能力

**一个CPU核心 通过时间片轮转 轮流服务多个线程**

微观上是串行，宏观感觉上是并行。

    超线程（Hyper Thread）技术：一个CPU核心可以同时执行两个线程。

### 2.3 应用

1) 异步调用

从方法调用的角度来讲，如果

* 需要等待结果返回，才能继续运行 -- 同步
* 不需要等待结果返回，就能继续运行 -- 异步

同步还有另外的意思：**让多个线程步调一致。**

2) 提高效率

- tomcat异步servlet，让用户线程处理耗时较长的操作，避免阻塞tomcat工作线程
- ui/ux编程中，新开线程处理耗时操作避免阻塞ui主线程

**注意：**

1.单核CPU，多线程编程并不能实际提高程序运行效率，只是为了能在不同的任务之间切换。

    切换线程运行的过程称为：上下文切换，耗时耗资源

2.多核CPU可以并行跑多个线程，但也不一定能提高程序的运行效率。

3.IO操作不占用CPU，我们一般拷贝文件使用的是【阻塞IO】，这时虽然线程不用cpu，但是要等IO结束，没能充分利用线程。所以后面才有【非阻塞IO】和【异步IO】。

## 3. Java线程

### 3.1 创建和运行线程

<h4>方法一，直接使用Thread</h4>

```java
//有名线程
Thread t = new Thread(["名字"]) {
    @Override
    public void run() {
        //To-Do
    }
};
//启动线程
t.start();

//直接新建并启动匿名线程
new Thread(() -> {
    //To-Do lambda表达式
}).start();
```

<h4>方法二，使用Runnable配合Thread</h4>

```java
Runnable runnable = new Runnable() {
    @Override
    public void run() {
        //TO-DO
    }
};

Thread t = new Thread(runnable);
t.start();
```

- 方法一 把线程和任务合并在一起
- 方法二 把线程和任务分开了
- 用Runnable更容易与线程池等高级API配合
- 用Runnable让任务脱离了Thread继承体系，满足依赖倒置原则，更灵活

<h4>方法三，FutureTask配合Thread</h4>

FutureTask能够接收Callable类型的参数，用来处理有返回结果的情况。

```java
Module java.base ⬇
package java.util.concurrent ⬇
public class FutureTask<V> implements RunnableFuture<T> ⬇
public interface RunnableFuture<V> extends Runnable, Future<V> 

@FunctionalInterface
public interface Callable<V> {
    V call() throws Exception;
}
```

Future<V>接口有一个`V get()`方法，能够返回执行的结果。

```java
FutureTask<Integer> task = new FutureTask<>(new Callable<Integer>() {
    @Override
    public Integer call() throws Exception {
        log.debug("running");
        Thread.sleep(2000);
        return 100;
    }
});

Thread t1 = new Thread(task, "t1");
t1.start();

log.debug("{}", task.get());
```